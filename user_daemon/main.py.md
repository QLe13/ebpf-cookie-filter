# Packet Analyzer Internal Documentation

[Linked Table of Contents](#table-of-contents)

## <a name="table-of-contents"></a>Table of Contents

* [1. Introduction](#introduction)
* [2. Class `PacketAnalyzer`](#class-packetanalyzer)
    * [2.1 `__init__` Method](#init-method)
    * [2.2 `attach` Method](#attach-method)
    * [2.3 `get_packet_deltas` Method](#get-packet-deltas-method)
    * [2.4 `log_packet_statistics` Method](#log-packet-statistics-method)
    * [2.5 `cleanup` Method](#cleanup-method)
* [3. `main` Function](#main-function)
* [4. Data Structures](#data-structures)
* [5. Algorithms](#algorithms)


## <a name="introduction"></a>1. Introduction

This document details the internal workings of the `PacketAnalyzer` Python application.  This application uses eBPF (extended Berkeley Packet Filter) to monitor network traffic, collect statistics, and send aggregate data to a remote dashboard.  The system leverages the `bcc` library for eBPF program interaction.


## <a name="class-packetanalyzer"></a>2. Class `PacketAnalyzer`

The core functionality resides within the `PacketAnalyzer` class.

### <a name="init-method"></a>2.1 `__init__` Method

The constructor initializes various class members:

*   `self.function_name`:  The name of the eBPF function defined in `config["ebpf_program"]`. This is loaded later to attach to the network interface.
*   `self.interface`: The network interface to monitor (from `config["network_interface"]`).
*   `self.packet_count_map`: A BPF map storing packet counts per source IP address.  Initialized to `None` and populated in `attach()`.
*   `self.local_packet_cache`: A Python dictionary acting as a local cache to store cumulative packet counts for each source IP. This avoids repeatedly querying the BPF map for delta calculations.
*   `self.total_packet_count`: A counter for the total number of packets processed.
*   `self.PacketInfo`: A `ctypes.Structure` defining the format of packet data received from the eBPF program.  This structure mirrors the `packet_info` struct defined in the eBPF program (see code comments for details).
*   `self.bpf`: An instance of the `BPF` class from the `bcc` library, loaded with the eBPF program specified in the configuration. The `cflags` are crucial for compiling the eBPF program correctly, ensuring it can find necessary kernel headers.


### <a name="attach-method"></a>2.2 `attach` Method

This method performs the following actions:

1.  **Loads the eBPF function:** Loads the eBPF function specified by `self.function_name` using `self.bpf.load_func(function_name, BPF.XDP)`.  `BPF.XDP` specifies that this function is an XDP (eXpress Data Path) program, meaning it runs in the kernel's data plane.
2.  **Attaches the eBPF program:** Attaches the loaded function to the specified network interface using `self.bpf.attach_xdp(self.interface, fn, 0)`. The `0` indicates that the program should be attached without any specific flags.
3.  **Retrieves the packet count map:** Gets a reference to the `packet_count` BPF map from the loaded BPF program.  This map is used to track packet counts per source IP address.
4.  **Sets up the perf buffer callback:** Registers a callback function (`print_packet_event`) which is invoked whenever a packet event is generated by the eBPF program.
5.  **Opens the perf buffer:** Opens the perf buffer associated with the `packet_events` event type, enabling the delivery of packet events to the registered callback function.


The `print_packet_event` callback function parses the packet data (converted from a raw byte array), formats IP addresses and port numbers, determines the protocol name based on the `packet_type` field and logs the packet details. It handles TCP-specific details (sequence, acknowledgment numbers, and flags) separately.  Crucially, it increments `self.total_packet_count`.

### <a name="get-packet-deltas-method"></a>2.3 `get_packet_deltas` Method

This method calculates the change in packet counts since the last poll:

1.  **Iterates through the packet count map:** Iterates through each entry in the `self.packet_count_map`.
2.  **Converts IP addresses:** Converts the source IP address (stored as an integer in the map) into a human-readable dotted-quad format.
3.  **Calculates deltas:** For each source IP, it calculates the difference between the current count from the BPF map and the previously recorded count from `self.local_packet_cache`.
4.  **Updates local cache:** Updates `self.local_packet_cache` with the current count.
5.  **Returns deltas:** Returns a dictionary containing the calculated packet count deltas for each source IP address.


### <a name="log-packet-statistics-method"></a>2.4 `log_packet_statistics` Method

This method simply logs the cumulative packet counts stored in `self.local_packet_cache`.


### <a name="cleanup-method"></a>2.5 `cleanup` Method

This method detaches the eBPF program from the network interface and performs cleanup operations on the BPF object.


## <a name="main-function"></a>3. `main` Function

The `main` function orchestrates the execution of the packet analyzer:

1.  **Initializes `PacketAnalyzer`:** Creates an instance of the `PacketAnalyzer` class.
2.  **Attaches to the network interface:** Calls the `attach()` method to load and attach the eBPF program.
3.  **Enters the main loop:** Enters an infinite loop that runs until interrupted by Ctrl+C.
4.  **Polls for perf buffer events:** Calls `analyzer.bpf.perf_buffer_poll(timeout=100)` to wait for packet events with a timeout of 100 milliseconds.
5.  **Gets and logs packet deltas:** Calls `get_packet_deltas()` to obtain packet count deltas and logs them.
6.  **Sends data to the dashboard:** Sends the total packet count to a remote dashboard API endpoint using the `requests` library. The data is formatted using the `helpers.format_packet_count` function (not shown in provided code). Error handling is included for API communication failures.
7.  **Sleeps:** Pauses for 1 second before the next iteration.
8.  **Handles Ctrl+C:** Gracefully exits the loop when Ctrl+C is pressed, and calls `analyzer.cleanup()` to detach the eBPF program and release resources.


## <a name="data-structures"></a>4. Data Structures

*   **`self.PacketInfo`:** A `ctypes.Structure` representing a single packet's data, containing fields for source and destination IP addresses, ports, protocol, packet length, and TCP-specific information (sequence number, acknowledgment number, flags).
*   **`self.local_packet_cache`:** A Python dictionary that maps source IP addresses (strings) to cumulative packet counts (integers).
*   **`self.packet_count_map`:** A BPF map (from the `bcc` library) that stores packet counts per source IP address.  The key is a `c_uint32` representing the source IP, and the value is a `c_uint32` representing the count.


## <a name="algorithms"></a>5. Algorithms

*   **Packet Count Delta Calculation:** The `get_packet_deltas` method employs a simple algorithm to compute the difference between current and previous packet counts for each source IP.  It uses a local cache (`self.local_packet_cache`) to efficiently track previous counts.
*   **eBPF Program (Not Shown):** The core algorithm for packet processing and counting resides within the eBPF program (`config["ebpf_program"]`), which is not included in this code snippet.  This program likely uses XDP hooks to intercept packets and increment counters based on source IP addresses.  This program would need to be separately documented.

